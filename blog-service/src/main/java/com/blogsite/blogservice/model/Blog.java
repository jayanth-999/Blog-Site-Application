package com.blogsite.blogservice.model;

import jakarta.persistence.*;
import jakarta.validation.constraints.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

/**
 * ========================================
 * BLOG ENTITY - DATABASE MODEL
 * ========================================
 * 
 * Represents a blog post in the system.
 * 
 * BUSINESS RULES (from requirements):
 * - Blog name: minimum 20 characters
 * - Category: minimum 20 characters  
 * - Article: minimum 1000 words
 * - All fields are mandatory
 * - Timestamp is set automatically
 */
@Entity
@Table(name = "blogs")
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class Blog {

    /**
     * PRIMARY KEY
     * Auto-generated by database
     */
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    /**
     * BLOG NAME
     * 
     * Must be at least 20 characters as per requirements.
     * 
     * @Column:
     * - nullable = false: Database constraint (NOT NULL)
     * - length = 200: Maximum length for the field
     */
    @NotBlank(message = "Blog name is required")
    @Size(min = 20, max = 200, message = "Blog name must be at least 20 characters")
    @Column(nullable = false, length = 200)
    private String blogName;

    /**
     * CATEGORY
     * 
     * Blogs are organized by categories.
     * Must be at least 20 characters.
     * 
     * Examples: "Technology and Innovation", "Travel and Adventure"
     */
    @NotBlank(message = "Category is required")
    @Size(min = 20, max = 100, message = "Category must be at least 20 characters")
    @Column(nullable = false, length = 100)
    private String category;

    /**
     * ARTICLE
     * 
     * The main blog content.
     * Must be at least 1000 words.
     * 
     * @Column(columnDefinition = "TEXT"):
     * - Stores large text (up to 64KB in MySQL)
     * - LONGTEXT could store even more
     * 
     * NOTE: We're validating minimum 1000 CHARACTERS as a proxy for words.
     * In a real application, you might count actual words.
     */
    @NotBlank(message = "Article is required")
    @Size(min = 1000, message = "Article must be at least 1000 characters")
    @Column(nullable = false, columnDefinition = "TEXT")
    private String article;

    /**
     * AUTHOR NAME
     * 
     * Who created this blog.
     * 
     * NOTE: In a more advanced design, this could be a foreign key
     * to the User table. For simplicity, we're storing the username.
     */
    @NotBlank(message = "Author name is required")
    @Size(min = 3, max = 50, message = "Author name must be between 3 and 50 characters")
    @Column(nullable = false, length = 50)
    private String authorName;

    /**
     * CREATED AT
     * 
     * Timestamp of when the blog was created.
     * Set automatically by @PrePersist callback.
     * 
     * Used for:
     * - Displaying creation date to users
     * - Filtering blogs by date range
     * - Sorting blogs chronologically
     */
    @Column(name = "created_at", updatable = false)
    private LocalDateTime createdAt;

    /**
     * UPDATED AT
     * 
     * Timestamp of last update.
     * Updated automatically by @PreUpdate callback.
     */
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

    /**
     * JPA LIFECYCLE CALLBACK - ON CREATE
     * 
     * Called automatically before inserting a new blog.
     * Sets creation timestamp to current time.
     */
    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
        updatedAt = LocalDateTime.now();
    }

    /**
     * JPA LIFECYCLE CALLBACK - ON UPDATE
     * 
     * Called automatically before updating an existing blog.
     * Updates the updatedAt timestamp.
     */
    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
    }
}
