<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>UserService.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">User Service</a> &gt; <a href="index.source.html" class="el_package">com.blogsite.userservice.service</a> &gt; <span class="el_source">UserService.java</span></div><h1>UserService.java</h1><pre class="source lang-java linenums">package com.blogsite.userservice.service;

import com.blogsite.userservice.dto.UserRegistrationRequest;
import com.blogsite.userservice.dto.UserResponse;
import com.blogsite.userservice.exception.UserAlreadyExistsException;
import com.blogsite.userservice.model.User;
import com.blogsite.userservice.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

/**
 * ========================================
 * USER SERVICE - BUSINESS LOGIC LAYER
 * ========================================
 * 
 * WHAT IS A SERVICE?
 * - Contains business logic (the &quot;rules&quot; of your application)
 * - Sits between Controller (handles HTTP) and Repository (handles database)
 * - Performs validation, transformations, and coordinates operations
 * 
 * LAYERED ARCHITECTURE:
 * 
 * Client → Controller → Service → Repository → Database
 *          (HTTP)     (Business)  (Data Access)
 * 
 * WHY SEPARATE LAYERS?
 * - Single Responsibility: Each layer has one job
 * - Testability: Can test business logic without HTTP or database
 * - Reusability: Service methods can be called from multiple controllers
 * - Maintainability: Easy to find and change business rules
 * 
 * ANNOTATIONS EXPLAINED:
 * 
 * @Service
 * - Marks this as a service component
 * - Spring automatically creates an instance (bean)
 * - Enables transaction management
 * 
 * @RequiredArgsConstructor (Lombok)
 * - Automatically creates constructor for 'final' fields
 * - This is DEPENDENCY INJECTION via constructor
 * - Spring will inject UserRepository when creating this service
 * 
 * @Slf4j (Lombok)
 * - Provides a logger instance: log
 * - Use like: log.info(&quot;User registered: {}&quot;, userName);
 * - Better than System.out.println()!
 * 
 * @Transactional
 * - Makes method execute in a database transaction
 * - If exception occurs, all database changes are rolled back
 * - Ensures data consistency
 */
@Service
<span class="fc" id="L57">@RequiredArgsConstructor</span>
<span class="fc" id="L58">@Slf4j</span>
public class UserService {

    /**
     * DEPENDENCY INJECTION
     * 
     * This field is 'final' - it must be set in constructor.
     * @RequiredArgsConstructor creates:
     * 
     * public UserService(UserRepository userRepository) {
     *     this.userRepository = userRepository;
     * }
     * 
     * Spring finds UserRepository bean and injects it automatically!
     * 
     * WHY DEPENDENCY INJECTION?
     * - No need to use 'new' keyword
     * - Easy to mock in tests
     * - Loose coupling between classes
     * - Spring manages object lifecycle
     */
    private final UserRepository userRepository;

    /**
     * ========================================
     * REGISTER NEW USER
     * ========================================
     * 
     * This method implements the user registration business logic.
     * 
     * STEPS:
     * 1. Check if email already exists
     * 2. Check if username already exists
     * 3. Create User entity from request DTO
     * 4. Save to database
     * 5. Convert entity to response DTO
     * 6. Return response
     * 
     * @Transactional ensures:
     * - If any step fails, no changes are saved
     * - Database operations are atomic (all or nothing)
     * 
     * EXAMPLE USAGE:
     * UserRegistrationRequest request = new UserRegistrationRequest(...);
     * UserResponse response = userService.registerUser(request);
     * 
     * @param request The registration request containing user data
     * @return UserResponse with user details (no password!)
     * @throws UserAlreadyExistsException if email or username already taken
     */
    @Transactional
    public UserResponse registerUser(UserRegistrationRequest request) {
        
        // STEP 1: Log the registration attempt
        // Logging is crucial for debugging and monitoring
<span class="fc" id="L113">        log.info(&quot;Attempting to register user with email: {}&quot;, request.getUserEmail());</span>

        // STEP 2: Check if email already exists
        // We use exists() instead of find() for better performance
        // We only care IF it exists, not WHAT the data is
<span class="fc bfc" id="L118" title="All 2 branches covered.">        if (userRepository.existsByUserEmail(request.getUserEmail())) {</span>
<span class="fc" id="L119">            log.warn(&quot;Registration failed: Email already exists: {}&quot;, request.getUserEmail());</span>
<span class="fc" id="L120">            throw new UserAlreadyExistsException(</span>
<span class="fc" id="L121">                &quot;A user with email '&quot; + request.getUserEmail() + &quot;' already exists&quot;</span>
            );
        }

        // STEP 3: Check if username already exists
<span class="fc bfc" id="L126" title="All 2 branches covered.">        if (userRepository.existsByUserName(request.getUserName())) {</span>
<span class="fc" id="L127">            log.warn(&quot;Registration failed: Username already exists: {}&quot;, request.getUserName());</span>
<span class="fc" id="L128">            throw new UserAlreadyExistsException(</span>
<span class="fc" id="L129">                &quot;A user with username '&quot; + request.getUserName() + &quot;' already exists&quot;</span>
            );
        }

        // STEP 4: Create User entity using Builder pattern
        // This is the Creational Design Pattern mentioned in requirements!
        // 
        // BUILDER PATTERN BENEFITS:
        // - Clear and readable
        // - Can set fields in any order
        // - Immutable construction
<span class="fc" id="L140">        User user = User.builder()</span>
<span class="fc" id="L141">                .userName(request.getUserName())</span>
<span class="fc" id="L142">                .userEmail(request.getUserEmail())</span>
<span class="fc" id="L143">                .password(request.getPassword())  // TODO: In production, hash this!</span>
<span class="fc" id="L144">                .build();</span>

        // STEP 5: Save to database
        // save() returns the saved entity with generated ID and timestamps
<span class="fc" id="L148">        User savedUser = userRepository.save(user);</span>
        
<span class="fc" id="L150">        log.info(&quot;User registered successfully with ID: {}&quot;, savedUser.getId());</span>

        // STEP 6: Convert Entity to Response DTO
        // We use the factory method from UserResponse
        // This ensures password is NOT included in response
<span class="fc" id="L155">        UserResponse response = UserResponse.fromEntity(savedUser);</span>

<span class="fc" id="L157">        return response;</span>
    }

    /**
     * ========================================
     * FIND USER BY EMAIL
     * ========================================
     * 
     * Retrieves user information by email address.
     * This could be used for login or profile lookup.
     * 
     * NOTE: In a real application, you'd have separate methods for
     * authentication that verify passwords securely.
     * 
     * @param email The email to search for
     * @return UserResponse if found
     * @throws RuntimeException if user not found (you can create a custom exception)
     */
    public UserResponse getUserByEmail(String email) {
<span class="nc" id="L176">        log.info(&quot;Searching for user with email: {}&quot;, email);</span>
        
        // findByUserEmail returns Optional&lt;User&gt;
        // Optional is a container that may or may not hold a value
<span class="nc" id="L180">        User user = userRepository.findByUserEmail(email)</span>
<span class="nc" id="L181">                .orElseThrow(() -&gt; new RuntimeException(&quot;User not found with email: &quot; + email));</span>

<span class="nc" id="L183">        return UserResponse.fromEntity(user);</span>
    }
}

/*
 * ========================================
 * DESIGN PATTERNS USED IN THIS CLASS
 * ========================================
 * 
 * 1. BUILDER PATTERN (Creational)
 *    - Used to construct User entity
 *    - Required by project specifications
 *    - Makes object creation clear and flexible
 * 
 * 2. FACTORY METHOD PATTERN (Creational)
 *    - UserResponse.fromEntity(user)
 *    - Encapsulates object creation logic
 *    - Consistent way to create response objects
 * 
 * 3. DEPENDENCY INJECTION PATTERN
 *    - UserRepository injected via constructor
 *    - Spring manages dependencies
 *    - Loose coupling, easy testing
 * 
 * 4. LAYERED ARCHITECTURE PATTERN
 *    - Clear separation: Controller → Service → Repository
 *    - Each layer has specific responsibility
 *    - Industry standard for web applications
 */
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>