# ========================================
# API GATEWAY CONFIGURATION
# ========================================

server:
  port: 8080  # Gateway runs on port 8080 (standard HTTP port)

spring:
  application:
    name: api-gateway

  # ========================================
  # SPRING CLOUD GATEWAY ROUTING
  # ========================================
  # 
  # Routes define how requests are forwarded to microservices.
  # Each route has:
  # - id: Unique identifier
  # - uri: Where to forward the request
  # - predicates: Conditions to match (path, method, headers, etc.)
  # - filters: Modifications to request/response
  #
  cloud:
    gateway:
      # Global CORS configuration
      # CORS = Cross-Origin Resource Sharing
      # Allows frontend apps from different domains to call your API
      globalcors:
        cors-configurations:
          '[/**]':  # Apply to all routes
            allowed-origins: "*"  # Allow any origin (for development)
            # In production, specify exact origins:
            # allowed-origins: "http://localhost:3000,https://yourdomain.com"
            allowed-methods:
              - GET
              - POST
              - PUT
              - DELETE
              - OPTIONS
            allowed-headers: "*"
            allow-credentials: false

      # ========================================
      # ROUTE DEFINITIONS
      # ========================================
      routes:
        # ========================================
        # USER SERVICE ROUTES
        # ========================================
        # Route all /api/v1.0/blogsite/user/** requests to User Service
        - id: user-service
          uri: http://localhost:8081  # User Service URL
          predicates:
            - Path=/api/v1.0/blogsite/user/**
          # filters:
          #   - StripPrefix=0  # Don't remove any path segments
          
        # ========================================
        # BLOG SERVICE ROUTES
        # ========================================
        # Route all /api/v1.0/blogsite/blogs/** requests to Blog Service
        - id: blog-service
          uri: http://localhost:8082  # Blog Service URL
          predicates:
            - Path=/api/v1.0/blogsite/blogs/**

        # Additional route for blog user-specific endpoints
        # (e.g., /api/v1.0/blogsite/user/blogs/**, /api/v1.0/blogsite/user/getall, /api/v1.0/blogsite/user/delete/**)
        - id: blog-service-user-endpoints
          uri: http://localhost:8082
          predicates:
            - Path=/api/v1.0/blogsite/user/blogs/**, /api/v1.0/blogsite/user/getall, /api/v1.0/blogsite/user/delete/**

        # ========================================
        # SWAGGER UI ROUTES (Optional)
        # ========================================
        # Forward Swagger UI requests to respective services
        - id: user-service-swagger
          uri: http://localhost:8081
          predicates:
            - Path=/user-service/swagger-ui/**,/user-service/v3/api-docs/**
          filters:
            - StripPrefix=1  # Remove '/user-service' prefix

        - id: blog-service-swagger
          uri: http://localhost:8082
          predicates:
            - Path=/blog-service/swagger-ui/**,/blog-service/v3/api-docs/**
          filters:
            - StripPrefix=1

# ========================================
# ACTUATOR ENDPOINTS (Health Check, Monitoring)
# ========================================
management:
  endpoints:
    web:
      exposure:
        include: health,info,gateway  # Expose health check and gateway routes info
  endpoint:
    health:
      show-details: always

# ========================================
# LOGGING
# ========================================
logging:
  level:
    root: INFO
    org.springframework.cloud.gateway: DEBUG  # See routing decisions
    reactor.netty: INFO

# ========================================
# HOW ROUTING WORKS
# ========================================
#
# EXAMPLE 1: User Registration
# Client Request:  POST http://localhost:8080/api/v1.0/blogsite/user/register
# Matches route:   user-service (Path=/api/v1.0/blogsite/user/**)
# Forwarded to:    POST http://localhost:8081/api/v1.0/blogsite/user/register
#
# EXAMPLE 2: Get Blogs by Category
# Client Request:  GET http://localhost:8080/api/v1.0/blogsite/blogs/info/Technology
# Matches route:   blog-service (Path=/api/v1.0/blogsite/blogs/**)
# Forwarded to:    GET http://localhost:8082/api/v1.0/blogsite/blogs/info/Technology
#
# EXAMPLE 3: Create Blog
# Client Request:  POST http://localhost:8080/api/v1.0/blogsite/user/blogs/add/MyBlog
# Matches route:   blog-service-user-endpoints
# Forwarded to:    POST http://localhost:8082/api/v1.0/blogsite/user/blogs/add/MyBlog
#
# ========================================
# TESTING THE GATEWAY
# ========================================
#
# 1. Start all services:
#    - User Service on port 8081
#    - Blog Service on port 8082
#    - API Gateway on port 8080
#
# 2. Test via Gateway:
#    curl -X POST http://localhost:8080/api/v1.0/blogsite/user/register \
#      -H "Content-Type: application/json" \
#      -d '{"userName":"test","userEmail":"test@example.com","password":"pass1234"}'
#
# 3. Check Gateway routes:
#    http://localhost:8080/actuator/gateway/routes
#
# ========================================
# ADVANCED FEATURES (Not Implemented)
# ========================================
#
# - Rate Limiting: Limit requests per user/IP
# - Circuit Breaker: Fallback if service is down
# - Load Balancing: Distribute load across multiple instances
# - Authentication: JWT validation at gateway
# - Request/Response transformation
#
# These are production features you can add later!
